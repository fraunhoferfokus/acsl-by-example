(* Generated by Frama-C WP *)

Goal typed_ref_external_lemma_AccumulateRead.
Hint AccumulateRead,property.
Proof.
  Require Import Psatz.
  intros init i.
  intros K L a.
  intro.
  assert (X: (i <= 0 \/ i > 0)%Z) by tauto.
  destruct X.
  {
    assert (L_Accumulate_1_ K a i init = init).
    {
      apply FixL_Accumulate_1_.
      assumption.
    }
    assert (L_Accumulate_1_ L a i init = init).
    {
      apply FixL_Accumulate_1_.
      assumption.
    }
    now rewrite H1.
  }
  apply natlike_rec3 with (z := i); auto with zarith.
  {
    assert (L_Accumulate_1_ K a 0 init = init).
    {
      apply FixL_Accumulate_1_.
      auto with zarith.
    }
    assert (L_Accumulate_1_ L a 0 init = init).
    {
      apply FixL_Accumulate_1_.
      auto with zarith.
    }
    now rewrite H1.
  }
  intros.
  replace (Z.pred z) with (z - 1)%Z in H2 by lia.
  assert ((K.[shift_sint32 a (z - 1)] + L_Accumulate_1_ K a (z - 1) init = L_Accumulate_1_ K a z init)%Z).
  {
    apply (@FixL_Accumulate_1_ z init K a).
    auto with zarith.
  }
  assert ((L.[shift_sint32 a (z - 1)] + L_Accumulate_1_ L a (z - 1) init = L_Accumulate_1_ L a z init)%Z).
  {
    apply (@FixL_Accumulate_1_ z init L a).
    auto with zarith.
  }
  rewrite <- H4.
  rewrite <- H5.
  assert (K.[shift_sint32 a (z - 1)] = L.[shift_sint32 a (z - 1)]).
  {
    rewrite H3; auto with zarith.
  }
  rewrite H6.
  enough(L_Accumulate_1_ K a (z - 1) init = L_Accumulate_1_ L a (z - 1) init) by lia.
  apply H2.
  clear H2 H4 H5 H6.
  unfold P_Unchanged_2_ in *.
  unfold P_Unchanged_1_ in *.
  intros.
  apply H3; auto with zarith.
Qed.

Goal typed_ref_external_lemma_AdjacentDifferenceInv.
Hint AdjacentDifferenceInv,property.
Proof.
  intros n L K a b H.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    intros.
    unfold P_Unchanged_2_ in *.
    unfold P_Unchanged_1_ in *.
    intros.
    intuition.
  }
  {
    intros.
    Require Import Psatz.
    replace (Z.succ z) with (1+z) in * by lia.

    assert(X: P_Unchanged_2_ L K a z). {
      apply H1; auto with zarith.
      - apply Q_UnchangedSection with (i_2 := 1+z) (i_3 := 0); auto with zarith.
      - apply Q_PartialSumSection with (i := 1+z); auto with zarith.
      - apply Q_AdjacentDifferenceSection with (i := 1+z); auto with zarith.
    } 

    unfold P_Unchanged_2_.
    unfold P_Unchanged_1_.
    intros.

    assert(Y: i < z \/ i = z) by lia.
    destruct Y as [less|equal].
    {
      apply X; auto with zarith.
    }
    {
      rewrite equal.
      rewrite H3; auto with zarith.
      rewrite <- Axiomatic1.Q_AccumulateDefaultNext; auto with zarith.
      rewrite <- H2; auto with zarith.
      rewrite H4; auto with zarith.

      assert (Z: z = 0 \/ z > 0) by lia.
      destruct Z as [zero|pos].
      {
        rewrite zero.
        unfold L_Difference.
        rewrite Axiomatic1.Q_AccumulateDefault0.
        auto with zarith.
      }
      {
        assert (L_Difference K a z = ((K.[shift_sint32 a z]) - (K.[shift_sint32 a (z-1)]))).
        {
          unfold L_Difference.
          replace (z <=? 0) with false.
          reflexivity.
          symmetry.
          rewrite Z.leb_gt.
          auto with zarith.
        }
        rewrite H7.
        cut ((K .[ shift_sint32 a (z - 1)]) = L_Accumulate_2_ L b z).
        - lia.
        - rewrite X; auto with zarith.
          rewrite H3; auto with zarith.
          replace (1 + (z-1)) with z by lia.
          trivial.
      }
    }
  }

Qed.

Goal typed_ref_external_lemma_Count2Inverse.
Hint Count2Inverse,property.
Proof.
  Require Import Psatz.
  intros v m n sum.
  intros L a.
  intros.
  inversion H0; subst; intuition.
  right.
  left.
  split; auto.
  split; auto.
  replace x with x0 in * by tauto.
  now replace (1 + i - 1)%Z with i by lia.
Qed.

Goal typed_ref_external_lemma_Count2NonNegativeSum.
Hint Count2NonNegativeSum,property.
Proof.
intros.
induction H0; auto with zarith.
Qed.

Goal typed_ref_external_lemma_Count2Read.
Hint Count2Read,property.
Proof.
  Require Import Psatz.
  intros v n sum.
  intros K L.
  intros a IV U.
  split.
  {
    intro CK.
   induction CK as [v i K| i sum K a | v i sum K].
    + now apply Q_Nil.
    + unfold x in *.
      unfold x_1 in *.
      assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]). {
        apply U; auto with zarith.
      }
      rewrite <- LK in *.
      apply Q_Hit; auto with zarith.
      apply IHCK; auto with zarith.
      apply Axiomatic.Q_UnchangedSection with (i_3 := 0%Z) (i_2 := i); auto with zarith.
    + unfold x in *.
      apply Q_Miss; auto with zarith.
      - assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]). {
          apply U; auto with zarith.
        }
        now rewrite LK.
      - apply IHCK; auto with zarith.
        apply Axiomatic.Q_UnchangedSection with (i_3 := 0%Z) (i_2 := i); auto with zarith.
  }
  intro CL.
  induction CL as [v i L| i sum L a | v i sum L].
  + now apply Q_Nil.
  + unfold x in *.
    unfold x_1 in *.
    assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]). {
      apply U; auto with zarith.
    }
    rewrite LK in *.
    apply Q_Hit; auto with zarith.
    apply IHCL; auto with zarith.
    apply Axiomatic.Q_UnchangedSection with (i_3 := 0%Z) (i_2 := i); auto with zarith.
  + unfold x in *.
    apply Q_Miss; auto with zarith.
    - assert (LK: L.[shift_sint32 a (i - 1)] = K.[shift_sint32 a (i - 1)]). {
        apply U; auto with zarith.
      }
      now rewrite <- LK.
    - apply IHCL; auto with zarith.
      apply Axiomatic.Q_UnchangedSection with (i_3 := 0%Z) (i_2 := i); auto with zarith.
Qed.

Goal typed_ref_external_lemma_CountBounds.
Hint CountBounds,property.
Proof.
  Require Import Psatz.
  intros v n M a.
  intros.
  subst x.
  apply natlike_rec2 with (z := n); auto with zarith.
  {
    (* base step *)
    rewrite <- Q_CountEmpty; auto with zarith.
  }
  {
    (* induction step *)
    intros.
    replace (Z.succ z) with (1 + z) by lia.
    assert (X: M.[ shift a z] = v \/ M.[ shift a z] <> v) by tauto.

    elim X; intros.
    - rewrite Q_CountHit; auto with zarith.
    - rewrite <- Q_CountMiss; auto with zarith.
  }

Qed.

Goal typed_ref_external_lemma_CountCount2Relation.
Hint CountCount2Relation,property.
Proof.
  Require Import Psatz.
  intros v n L a IV.
  assert (n <= 0 \/ n > 0)%Z by tauto.
  destruct H as [le|gt].
  {
   assert (Nil: (L_Count_2_ L a n v = 0)%Z) by now apply A_CountAxiomatic.Q_CountSectionEmpty.
   rewrite Nil.
    apply Q_Nil; auto with zarith.
  }
  apply natlike_rec3 with (z := n); auto with zarith.
  + assert (Nil: (L_Count_2_ L a 0 v = 0)%Z) by now apply A_CountAxiomatic.Q_CountSectionEmpty.
    rewrite Nil.
    apply Q_Nil; auto with zarith.
  + intros z Z Step.
    replace (Z.pred z) with (z - 1)%Z in * by lia.
    assert (L.[shift_sint32 a (z - 1)] <> v \/ L.[shift_sint32 a (z - 1)] = v) by tauto.
    destruct H as [Ne|Eq].
    - assert (Miss: L_Count_2_ L a (z - 1) v = L_Count_2_ L a z v) by
      (apply A_CountAxiomatic.Q_CountSectionMiss; auto with zarith).
      rewrite <- Miss.
      apply Q_Miss; auto with zarith.
    - assert (Hit: (1 + L_Count_2_ L a (z - 1) v = L_Count_2_ L a z v)%Z) by
      (rewrite <- Eq in *; apply A_CountAxiomatic.Q_CountSectionHit; auto with zarith).
      rewrite <- Hit.
      rewrite <- Eq in *.
      apply Q_Hit; auto with zarith.
Qed.

Goal typed_ref_external_lemma_CountSectionBounds.
Hint CountSectionBounds,property.
Proof.
  Require Import Psatz.
  intros.
  subst x.
  remember i_1 as m.
  remember i   as n.
  remember i_2 as v.

  replace n with (m + (n-m))%Z by lia.
  apply natlike_rec2 with (z := (n - m)%Z); auto with zarith.
  {
    rewrite Zplus_0_r.
    rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
  }
  {
    intros.
    replace (m + Z.succ z)%Z with (1 + (m+z))%Z by lia.

    assert (X: t.[ shift_sint32 a (m+z)] =  v \/
               t.[ shift_sint32 a (m+z)] <> v) by lia.
    destruct X as [eq|neq].
    - remember (m+z)%Z as mz.
      remember (1+mz)%Z as mz1.
      replace mz with (mz1 - 1)%Z in * by lia.
      rewrite <- eq in *.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
    - rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
      + replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
        auto with zarith.
      + replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
        auto with zarith.
  }
Qed.

Goal typed_ref_external_lemma_CountSectionMonotonic.
Hint CountSectionMonotonic,property.
Proof.
  Require Import Psatz.
  intros.
  remember i_3 as v.
  remember i_2 as m.
  remember i   as p.
  remember i_1 as n.

  replace p with (n + (p-n))%Z by lia.
  apply natlike_rec2 with (z := (p - n)%Z); auto with zarith.
  {
    replace (n+0)%Z with n by lia.
    lia.
  }
  {
    intros.
    replace (n + Z.succ z)%Z with (1 + (n+z))%Z by lia.
    apply  Z.ge_le.

    assert (X: t.[ shift_sint32 a (n+z)] =  v \/
               t.[ shift_sint32 a (n+z)] <> v) by lia.
    destruct X as [eq|neq].
    - remember (n+z)%Z as nz.
      remember (1+nz)%Z as nz1.
      replace nz with (nz1 - 1)%Z in * by lia.
      rewrite <- eq in *.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
    - rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
      + replace (1 + (n + z) - 1)%Z with (n + z)%Z by lia.
        auto with zarith.
      + replace (1 + (n + z) - 1)%Z with (n + z)%Z by lia.
        auto.
  }
Qed.

Goal typed_ref_external_lemma_CountSectionRead.
Hint CountSectionRead,property.
Proof.
  Require Import Psatz.
  intros v m n L K a V.

  assert(X: (n <= m \/ n > m)%Z) by tauto.
  destruct X as [leq|greater].
  {
    intros.
    rewrite Q_CountSectionEmpty; auto with zarith.
    rewrite Q_CountSectionEmpty; auto with zarith.
  }
  {
    pose (p := (n - m)%Z).
    replace n with (m + p)%Z in * by (subst p; auto with zarith).
    assert(Pos: (p > 0)%Z) by lia.

    apply natlike_rec2 with (z := p); auto with zarith.
    {
      intros.
      rewrite Q_CountSectionEmpty; auto with zarith.
      rewrite Q_CountSectionEmpty; auto with zarith.
    }
    {
      intros.
      replace (m + Z.succ z)%Z with (1 + (m + z))%Z in * by lia.
      assert (Equal: L.[ shift_sint32 a (m + z)] = K.[ shift_sint32 a (m + z)]). {
        rewrite H1; auto with zarith.
      }

      assert (Value: L.[ shift_sint32 a (m + z)] = v \/ L.[ shift_sint32 a (m + z)] <> v) by tauto.
      destruct Value as [eq|neq].
      - assert(eq_K: K .[ shift_sint32 a (m + z)] = v) by auto with zarith.
        replace (m + z)%Z with (1 + (m + z) - 1)%Z in eq, eq_K, Equal by lia.
        rewrite <- eq.
        rewrite <- Q_CountSectionHit; auto with zarith.
        + rewrite Equal.
          rewrite <- Q_CountSectionHit; auto with zarith.
          * replace (1 + (m + z) - 1)%Z with (m+z)%Z in * by lia.
            rewrite eq_K.
            enough (L_Count_1_ L a m (m + z) v = L_Count_1_ K a m (m + z) v) by lia.
            apply H0.
            unfold P_Unchanged_1_.
            intros.
            apply H1; auto with zarith.
          * replace (1 + (m + z) - 1)%Z with (m+z)%Z in * by lia.
            now rewrite eq_K.
        + replace (1 + (m + z) - 1)%Z with (m+z)%Z in * by lia.
          now rewrite eq.
      - assert(neq_K: K .[ shift_sint32 a (m + z)] <> v) by auto with zarith.
        replace (m + z)%Z with (1 + (m + z) - 1)%Z in neq, neq_K, Equal by lia.
        rewrite <- Q_CountSectionMiss; auto with zarith.
        replace (1 + (m + z) - 1)%Z with (m+z)%Z by lia.
        symmetry.
        rewrite <- Q_CountSectionMiss; auto with zarith.
        replace (1 + (m + z) - 1)%Z with (m+z)%Z in * by lia.
        symmetry.
        apply H0.
        unfold P_Unchanged_1_.
        intros.
        apply H1; auto with zarith.
    }
  }
Qed.

Goal typed_ref_external_lemma_CountSectionUnion.
Hint CountSectionUnion,property.
Proof.
  Require Import Psatz.
  intros v k m n L a.
  intros.

  replace n with (m + (n-m))%Z by lia.
  apply natlike_rec2 with (z := (n - m)%Z); auto with zarith.
  {
    rewrite Zplus_0_r.
    rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
  }
  {
    intros.
    replace (m + Z.succ z)%Z with (1 + (m+z))%Z by lia.

    assert (X: v = L.[ shift_sint32 a (m+z)] \/ v <> L.[ shift_sint32 a (m+z)]) by tauto.
    destruct X as [eq|neq].
    {
      rewrite eq in *.
      remember (m+z)%Z as mz.
      remember (1+mz)%Z as mz1.
      replace mz with (mz1 - 1)%Z in * by lia.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
      symmetry.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
    }
    {
      rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
      replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
      symmetry.
      rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
      replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
      auto with zarith.
      - replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
        auto.
      - replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
        auto.
    }
  }
Qed.

Goal typed_ref_external_lemma_CountShift.
Hint CountShift,property.
Proof.
  Require Import Psatz.
  intros v m n t a.
  intros.

  apply natlike_rec2 with (z := n); auto with zarith.
  {
    replace (0 + m)%Z with m by lia.
    rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
    rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
  }
  {
    intros.
    replace (Z.succ z) with (1 + z)%Z by auto with zarith.
    rewrite <- Q_CountSectionOne; auto with zarith.
    replace (1 + z + m)%Z with (1 + (z + m))%Z by lia.
    symmetry.
    rewrite <- Q_CountSectionOne; auto with zarith.

    cut(L_Count_1_ t a (z + m) (1 + (z + m)) v =
        L_Count_1_ t (shift_sint32 a m) z (1 + z) v).
    {
      intros.
      rewrite H3.
      rewrite <- H4.
      trivial.
    }
    {
      remember (t.[shift_sint32 a (z + m)]) as azm.
      assert (X: azm = v \/ azm <> v) by lia.
      destruct X as [eq|neq].
      {
        subst azm.
        remember  (z + m)%Z   as  zm.
        remember  (1 + zm)%Z  as  zm1.
        replace zm with (zm1 - 1)%Z in * by lia.
        rewrite <- eq in *.
        rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
        rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.

        remember (shift_sint32 a m) as am.
        remember (1 + z)%Z as z1.
        assert(remember_z: z = (z1 - 1)%Z) by lia.
        rewrite remember_z in *.
        enough (Y: t.[ shift_sint32 a (zm1 - 1)] = t.[shift_sint32 am (z1 - 1)]).
        - rewrite Y in *.
          rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
          rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
        - subst am.
          rewrite Heqzm in *.
          rewrite <- remember_z in *.
          unfold shift_sint32.
          rewrite shift_associative.
          now replace (z + m)%Z with (m + z)%Z by lia.
      }
      {
         rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
         rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
         rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
         - replace (1 + z - 1)%Z with z by lia.
           rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
         - replace (1 + z - 1)%Z with z by lia.
           unfold shift_sint32 in *.
           rewrite shift_associative.
           replace (m + z)%Z with (z + m)%Z by lia.
           lia.
         - replace (1 + (z + m) - 1)%Z with (z + m)%Z by lia.
           lia.
       }
    }
  }
Qed.

Goal typed_ref_external_lemma_EqualRangesPreservesCount.
Hint EqualRangesPreservesCount,property.
Proof.
  Require Import Psatz.
  intros v m n p L K a. intros P Q V.
  replace n with (m + (n-m))%Z by lia.


  apply natlike_rec2 with (z := (n - m)%Z); auto with zarith.
  {
    intros.
    rewrite Zplus_0_r in *.
    replace (p + m - m)%Z with p by lia.
    rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
    rewrite A_CountAxiomatic.Q_CountSectionEmpty; auto with zarith.
  }
  {
    intros z.
    replace (p + (m + z) - m)%Z with (p + z)%Z by lia.
    replace (m + Z.succ z)%Z with (1 + (m+z))%Z by lia.
    replace (p + (1 + (m + z)) - m)%Z with (1 + (p + z))%Z by lia.
    intros.
    assert(Y: P_EqualRanges_4_ L K a m (m + z) p).
    {
      unfold P_EqualRanges_4_ in *.
      unfold P_EqualRanges_3_ in *.
      unfold P_EqualRanges_1_ in *.
      unfold shift_sint32 in *.
      intros.
      rewrite H1; auto with zarith.
    }

    assert (X: K.[ shift_sint32 a (m+z)] =  v \/ K.[ shift_sint32 a (m+z)] <> v) by lia.
    destruct X as [eq|neq].
    {
      assert(APZ: v = L.[ shift_sint32 a (p + z)]).
      {
          rewrite <- eq.
          rewrite <- shift_associative.
          replace (K .[ shift (shift a m) z]) with (K.[ shift_sint32 (shift_sint32 a m) z]) by auto.
          rewrite H1; auto with zarith.
          rewrite shift_associative; auto.
      }
      remember  (p + z)%Z as pz.
      remember  (1 + pz)%Z as pz1.
      replace   pz with (pz1 - 1)%Z in * by lia.
      rewrite APZ in *.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
      rewrite Heqpz in *.

      symmetry.
      remember  (m + z)%Z as mz.
      remember  (1 + mz)%Z as mz1.
      replace   mz with (mz1 - 1)%Z in * by lia.
      rewrite <- APZ in *.
      rewrite <- eq in *.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
      symmetry.
      auto with zarith.
    }
    {
      rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
      - replace (1 + (p + z) - 1)%Z with (p + z)%Z by lia.
        symmetry.
        rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
        + replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
          symmetry.
          auto with zarith.
        + replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
          auto.
      - replace (1 + (p + z) - 1)%Z with (p + z)%Z by lia.
        unfold P_EqualRanges_4_ in H1.
        unfold P_EqualRanges_3_ in H1.
        unfold P_EqualRanges_1_ in H1.
        unfold shift_sint32 in *.
        rewrite <- shift_associative; auto with zarith.
        rewrite <- H1; auto with zarith.
        rewrite shift_associative; auto with zarith.
    }
  }
Qed.

Goal typed_ref_external_lemma_EqualRangesPreservesSorted.
Hint EqualRangesPreservesSorted,property.
Proof.
 Require Import Psatz.
 intros m n p L K a; intros.
 subst x.
 unfold P_Sorted_1_.
 unfold P_EqualRanges_4_ in *.
 unfold P_EqualRanges_3_ in *.
 unfold P_EqualRanges_1_ in *.
 intros i j; intros.
 unfold shift_sint32 in *.

 replace i with ((p + m) + (i - p - m))%Z by lia.
 rewrite <- shift_associative.
 rewrite <- H0; auto with zarith.

 replace j with ((p + m) + (j - p - m))%Z by lia.
 rewrite <- shift_associative.
 rewrite <- H0; auto with zarith.

 rewrite shift_associative.
 rewrite shift_associative.

 apply H; auto with zarith.
Qed.

Goal typed_ref_external_lemma_HasValueImpliesPositiveCount.
Hint HasValueImpliesPositiveCount,property.
Proof.
  Require Import Psatz.
  intros v m n L a.
  intros A B.

  pose (p := (n - m)%Z).
  assert (non_negative: (p >= 0)%Z).
  {
    subst p.
    lia.
  }

  replace n with (m + p)%Z in * by (subst p; auto with zarith).

  apply natlike_rec2 with (z := p); auto with zarith.
  {
   replace (m + 0)%Z with m by lia.
   intros.
   unfold P_HasValue_1_ in H0.
   destruct H0 as [k [X Y]].
   exfalso.
   intuition.
  }
  {
    intros.
    rename H0 into IndStep.
    rename H2 into IndHyp.
    replace (Z.succ z) with (1 + z)%Z in * by lia.
    replace (m + (1 + z))%Z with (1 + (m + z))%Z in * by lia.

    assert (Value: L.[ shift_sint32 a (m + z)] = v \/ L.[ shift_sint32 a (m + z)] <> v) by lia.
    destruct Value as [eq|neq].
    {
      remember  (m+z)%Z as mz.
      remember  (1 + mz)%Z as mz1.
      replace mz with (mz1 - 1)%Z in * by lia.
      rewrite <- eq in *.
      rewrite <- A_CountAxiomatic.Q_CountSectionHit; auto with zarith.
      assert (X: (0 <= (L_Count_1_ L a m (m + z) v))%Z).
      - apply Q_CountSectionBounds; auto with zarith.
        rewrite <- eq in *.
        auto with zarith.
      - rewrite Heqmz in *.
        rewrite <- eq in *.
        auto with zarith.
    }
    {
      rewrite <- A_CountAxiomatic.Q_CountSectionMiss; auto with zarith.
      - replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
        apply IndStep; auto with zarith.
        unfold P_HasValue_1_ in IndHyp.
        destruct IndHyp as [k [X Y]].
        unfold P_HasValue_1_.
        exists k.
        split; auto with zarith.
        enough (Z: (m <= k < m + z \/ k = m + z)%Z).
        + destruct Z as [less|equal]; auto.
          rewrite equal in X.
          exfalso.
          intuition.
        + assert(ZZ: (k < m + z \/ k >= m + z)%Z) by tauto.
          destruct ZZ as [le|geq]; auto with zarith.
      - now replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
     }
  }
Qed.

Goal typed_ref_external_lemma_HeapMaximum.
Hint HeapMaximum,property.
Proof.
  Require Import Psatz.
  intros.

  (* for me it somehow easier to first proof this slight reformulation and apply it later *)
  assert(Reformulate:
           (forall (i : int) (s : farray addr int) (b : addr),
            let x := 1 + i in 0 <= i -> P_IsHeap s b x -> P_MaxElement s b x 0)%Z).
  {
    intros n s b.
    intros x A.
    subst x.
    apply natlike_rec2 with (z := n); auto with zarith.
    {
      rewrite Zplus_0_r.
      intros.
      unfold P_MaxElement.
      split; auto with zarith.
      split; auto with zarith.
      unfold P_UpperBound_2_.
      unfold P_UpperBound_1_.
      intros.
      replace i0%Z with 0%Z by lia.
      lia.
    }
    {
      intros z.
      intros.
      replace (Z.succ z) with (1+z)%Z in * by lia.

       assert(X: P_IsHeap s b (1+z)).
       {
         unfold P_IsHeap.
         intros.
         apply H3; auto with zarith.
       }
       assert(Y: P_MaxElement s b (1+z) 0).
       {
        apply H2; auto with zarith.
       }
       unfold P_MaxElement.
       unfold P_UpperBound_2_.
       unfold P_UpperBound_1_.
       split; auto with zarith.
       split; auto with zarith.
       intros.

       assert(less_equal: (i0 < 1+z \/ i0 = 1+z)%Z) by lia.
       destruct less_equal as [less|equal].
       {
         apply Y; auto with zarith.
       }
       {
         rewrite equal.
         assert(Z: (s .[ shift_sint32 b (1+z)] <= s .[ shift_sint32 b (L_HeapParent (1+z))])%Z).
         {
           apply H3; auto with zarith.
         }
         assert(ZZ: (s .[ shift_sint32 b (L_HeapParent (1+z))] <= s .[ shift_sint32 b 0])%Z).
         {
           unfold L_HeapParent.
           replace (1+z-1)%Z with z by lia.
           apply Y; auto with zarith.
           apply Q_C_Division_2; lia.
           cut (Cdiv z 2 <= z)%Z; auto with zarith.
           apply Q_C_Division_2; lia.
         }
         lia.
       }
     }
  }

  replace i with (1+(i-1))%Z by lia.
  apply Reformulate; auto with zarith.
  now replace (1+(i-1))%Z with i by lia.
Qed.

Goal typed_ref_external_lemma_InnerProductRead.
Hint InnerProductRead,property.
Proof.
  Require Import Psatz.
  intros init n L K a b.
  intro.
  assert (X: (n <= 0 \/ n > 0)%Z) by lia.
  destruct X as [lez|gtz].
  {
    intros.
    assert (L_InnerProduct L a b n init = init).
    {
      now apply FixL_InnerProduct.
    }
    assert (L_InnerProduct K a b n init = init).
    {
      now apply FixL_InnerProduct.
    }
    now rewrite H2.
  }
  apply natlike_rec3 with (z := n); auto with zarith.
  {
    intros.
    assert (L_InnerProduct L a b 0 init = init).
    {
      now apply FixL_InnerProduct.
    }
    assert (L_InnerProduct K a b 0 init = init).
    {
      now apply FixL_InnerProduct.
    }
    now rewrite H2.
  }

  intro.
  replace (Z.pred z) with (z - 1)%Z in * by lia.
  intros.
  assert (((L_InnerProduct L a b (z-1) init) + (L.[shift_sint32 b (z-1)]) * (L.[shift_sint32 a (z-1)]) 
             = L_InnerProduct L a b z init)%Z ).
  {
    apply (@FixL_InnerProduct z init L a b); auto with zarith.
  }
  assert (((L_InnerProduct K a b (z-1) init) + (K.[shift_sint32 b (z-1)]) * (K.[shift_sint32 a (z-1)]) 
            = L_InnerProduct K a b z init)%Z ).
  {
    apply (@FixL_InnerProduct z init K a b); auto with zarith.
  }
  rewrite <- H4.
  rewrite <- H5.
  assert (K.[ shift_sint32 b (z - 1)] = L.[ shift_sint32 b (z - 1)]).
  {
    apply H2; auto with zarith.
  }
  assert (K.[ shift_sint32 a (z - 1)] = L.[ shift_sint32 a (z - 1)]).
  {
    apply H3; auto with zarith.
  }
  rewrite H6.
  rewrite H7.
  enough (L_InnerProduct L a b (z-1) init = L_InnerProduct K a b (z-1) init) by lia.
  apply H1.
  {
   unfold P_Unchanged_2_ in *.
   unfold P_Unchanged_1_ in *.
   intros.
   apply H2; auto with zarith.
  }
  unfold P_Unchanged_2_ in *.
  unfold P_Unchanged_1_ in *.
  intros.
  apply H3; auto with zarith.
Qed.

Goal typed_ref_external_lemma_LowerBoundShift.
Hint LowerBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_LowerBound_1_.
  intros val b c d L a H0 LowerBound i X Y.

  replace i with (b + (i - b))%Z by lia.
  rewrite <- shift_associative.
  apply LowerBound; lia.

Qed.

Goal typed_ref_external_lemma_MultisetUnchangedUnion.
Hint MultisetUnchangedUnion,property.
Proof.
  unfold P_MultisetUnchanged_1_ in *.
  intros.
  remember i0 as v.
  remember i as n.
  remember i_1 as k.

  rewrite Q_CountSectionUnion with (i_1 := k); auto with zarith.
  symmetry.
  rewrite Q_CountSectionUnion with (i_1 := k); auto with zarith.
  rewrite H1; auto with zarith.
  rewrite H2; auto with zarith.

Qed.

Goal typed_ref_external_lemma_PartialReorderPreservesLowerBounds.
Hint PartialReorderPreservesLowerBounds,property.
Proof.
  intros m n L K a.
  intros.

  cut (P_LowerBound_1_ K a m n (L .[ shift_sint32 a 0])).
  {
    unfold P_LowerBound_1_.
    intros.
    apply Z.ge_le.
    rewrite <- H1; auto with zarith.
    apply Z.le_ge.
    apply H4; auto with zarith.
  }

  enough (X: P_HasValue_1_ K a 0 m (L .[ shift_sint32 a 0])).
  + unfold P_HasValue_1_ in X.
    destruct X as [k [A B]].
    rewrite <- A.
    apply H3; auto with zarith.
  + apply Q_ReorderImpliesMatch; auto with zarith.
Qed.

Goal typed_ref_external_lemma_PositiveCountImpliesHasValue.
Hint PositiveCountImpliesHasValue,property.
Proof.
  Require Import Psatz.
  intros v m n L a.
  intros A B.

  pose (p := (n - m)%Z).
  assert (non_negative: (p >= 0)%Z); auto with zarith.

  replace n with (m + p)%Z in *.
  apply natlike_rec2 with (z := p); auto with zarith.
  {
   replace (m + 0)%Z with m by lia.
   intros.
   rewrite A_CountAxiomatic.Q_CountSectionEmpty in H; auto with zarith.
   exfalso.
   intuition.
  }
  {
    intros.
    rename H0 into IndStep.
    rename H1 into IndHyp.
    replace (Z.succ z) with (1 + z)%Z in * by lia.
    replace (m + (1 + z))%Z with (1 + (m + z))%Z in * by lia.

    assert (Value: L.[ shift a (m + z)] = v \/ L.[ shift a (m + z)] <> v) by tauto.
    destruct Value as [eq|neq].
    {
      unfold P_HasValue_1_.
      exists (m + z)%Z.
      split; auto with zarith.
    }
    {
      rewrite <- A_CountAxiomatic.Q_CountSectionMiss in IndHyp; auto with zarith.
      replace (1 + (m + z) - 1)%Z with (m + z)%Z in * by lia.
       - cut (P_HasValue_1_ L a m (m + z) v).
          + unfold P_HasValue_1_ .
            intros X.
            destruct X as [k [P Q]].
            exists k.
            split; auto with zarith.
          + now apply IndStep.
        - replace (1 + (m + z) - 1)%Z with (m + z)%Z by lia.
          unfold shift_sint32.
          auto with zarith.
      }
    }

    subst p; lia.
Qed.

Goal typed_ref_external_lemma_RemovePartitionUpperBound.
Hint RemovePartitionUpperBound,property.
Proof.
  Require Import Psatz.
  intros v p n L a.
  intros.
  assert(X: L_RemovePartition L a n v p < L_RemovePartition L a n v (L_RemoveSize L a n v)).
  - apply A_RemovePartitionAxiomatic.Q_RemovePartitionMonotone; auto with zarith.
  - assert(Y:  n = (L_RemovePartition L a n v (L_RemoveSize L a n v))).
    + rewrite A_RemovePartitionAxiomatic.Q_RemovePartitionRight; auto with zarith.
    + now rewrite <- Y in X.
Qed.

Goal typed_ref_external_lemma_RemoveSizeMonotonic.
Hint RemoveSizeMonotonic,property.
Proof.
  Require Import Psatz.
  unfold L_RemoveSize in *.
  intros v m n M a.
  intros.

  cut(m + (L_Count_2_ M a n v) <= n + (L_Count_2_ M a m v)); auto with zarith.
  rewrite <- Q_CountUnion with (i_1 := m); auto with zarith.
  unfold L_Count_2_.
  cut (m + L_Count_1_ M a m n v <= n); auto with zarith.
  apply Q_CountSectionBounds; auto with zarith.
Qed.

Goal typed_ref_external_lemma_ReorderImpliesMatch.
Hint ReorderImpliesMatch,property.
Proof.
  intros i n L K a.
  intros.
  unfold P_HasValue_2_.
  unfold P_MultisetUnchanged_2_ in H1.
  unfold P_MultisetUnchanged_1_ in H1.
  (* unfold shift_sint32 in *. *)

  remember (L .[ shift_sint32 a i]) as v.

  (* work around for https://bts.frama-c.com/view.php?id=2332 *)
  assert(CType: is_sint32 v) by admit.

  assert(Has: P_HasValue_1_ L a 0 n v).
  - unfold P_HasValue_1_.
    exists i.
    auto with zarith.
  - assert (Pos: (0 < L_Count_1_ L a 0 n v)%Z).
    + apply Q_HasValueImpliesPositiveCount; auto with zarith.
    + apply Q_PositiveCountImpliesHasValue; auto with zarith.
      now rewrite H1.
Admitted.

Goal typed_ref_external_lemma_ReorderPreservesLowerBound.
Hint ReorderPreservesLowerBound,property.
Proof.
  intros n v L K a. intros.
  assert(n_cases: (0 < n \/ 0 = n \/ 0 > n)%Z) by apply Ztrichotomy.
  destruct n_cases as [pos | non_pos].
  -
    unfold P_LowerBound_2_.
    unfold P_LowerBound_1_.
    intros.
    assert (X: P_HasValue_2_ K a n (L .[ shift_sint32 a i])).
    + apply Q_ReorderImpliesMatch; auto with zarith.
    + unfold P_HasValue_2_ in X.
      unfold P_HasValue_1_ in X.
      destruct X as [k [A B]].
      rewrite <- A.
      now apply H2.
  -
    unfold P_LowerBound_2_.
    unfold P_LowerBound_1_.
    auto with zarith.
Qed.

Goal typed_ref_external_lemma_ReorderPreservesUpperBound.
Hint ReorderPreservesUpperBound,property.
Proof.
  intros n v L K a. intros.
  assert(n_cases: (0 < n \/ 0 = n \/ 0 > n)%Z) by apply Ztrichotomy.
  destruct n_cases as [pos | non_pos].
  -
    unfold P_UpperBound_2_.
    unfold P_UpperBound_1_.
    intros.
    assert (X: P_HasValue_2_ K a n (L .[ shift_sint32 a i])).
    + apply Q_ReorderImpliesMatch; auto with zarith.
    + unfold P_HasValue_2_ in X.
      unfold P_HasValue_1_ in X.
      destruct X as [k [A B]].
      rewrite <- A.
      now apply H2.
  -
    unfold P_UpperBound_2_.
    unfold P_UpperBound_1_.
    auto with zarith.
Qed.

Goal typed_ref_external_lemma_RetainAllButOneMiss.
Hint RetainAllButOneMiss,property.
Proof.
  Require Import Psatz.
  intros.

  remember a_1 as A.
  remember a   as B.
  remember i_2 as v.
  remember i_1 as m.
  remember i   as n.
  remember t   as K.
  remember t_1 as L.

  subst x a_2.
  unfold P_RetainAllButOne in *.
  intros x. intros.

  assert(X: x =  L .[ shift_sint32 A m] \/ x <> L .[ shift_sint32 A m]) by lia.

  destruct X as [eq|neq].
  {
    rewrite Q_CountHit; auto with zarith.
    rewrite <- Q_CountRead with (t := K); auto with zarith.
    - symmetry.
      rewrite Q_CountHit; auto with zarith.
      rewrite <- Q_CountRead with (t := K); auto with zarith.
      rewrite <- H5; auto with zarith.
    - apply Q_UnchangedSection with (i := 1+m); auto with zarith.
  }
  {
    rewrite <- Q_CountMiss; auto with zarith.
    rewrite <- Q_CountRead with (t := K); auto with zarith.
    - symmetry.
      rewrite <- Q_CountMiss; auto with zarith.
      rewrite <- Q_CountRead with (t := K); auto with zarith.
      rewrite H5; auto with zarith.
    - apply Q_UnchangedSection with (i := 1+m); auto with zarith.
  }

Qed.

Goal typed_ref_external_lemma_RotatePreservesStrictLowerBound.
Hint RotatePreservesStrictLowerBound,property.
Proof.
  Require Import Psatz.
  intros m n L K a. intros.
  subst x. subst x_1.
  unfold P_StrictLowerBound_1_ in *.
  intros.
  unfold P_EqualRanges_4_ in *.
  unfold P_EqualRanges_3_ in *.
  unfold P_EqualRanges_1_ in *.

  unfold shift_sint32 in *.

  replace m with (m + 0)%Z by lia.
  rewrite <- shift_associative.
  rewrite <- H; auto with zarith.

  replace i with ((1 + m) + (i - (1 + m)))%Z by lia.
  rewrite <- shift_associative.
  rewrite <- H0; auto with zarith.

  rewrite shift_associative.
  rewrite shift_associative.

  replace (n + 0)%Z with n by lia.
  replace (m + (i - (1 + m)))%Z with (i - 1)%Z by lia.
  apply H1; auto with zarith.
Qed.

Goal typed_ref_external_lemma_StrictLowerBoundShift.
Hint StrictLowerBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictLowerBound_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_2 + (i0 - i_2))%Z by lia.

  rewrite <- shift_associative.
  apply H0; lia.

Qed.

Goal typed_ref_external_lemma_StrictUpperBoundShift.
Hint StrictUpperBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_StrictUpperBound_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1))%Z by lia.

  rewrite <- shift_associative.
  apply H0; lia.

Qed.

Goal typed_ref_external_lemma_SwappedInsideMultisetUnchanged.
Hint SwappedInsideMultisetUnchanged,property.
Proof.
  Require Import Psatz.
  intros i k n L K a.
  intros.
  unfold P_SwappedInside in H.
  destruct H as [A1 [A2 [A3 [A4 [A5 [A6 [A7 A8]]]]]]].

  unfold P_MultisetUnchanged_1_.
  intros v. intros.
  rewrite <- Q_CountSectionOne; auto with zarith.
  symmetry.
  rewrite <- Q_CountSectionOne; auto with zarith.
  rewrite <- Q_CountSectionUnion with (i_1 := 1+i); auto with zarith.
  symmetry.
  rewrite <- Q_CountSectionUnion with (i_1 := 1+i); auto with zarith.

  enough (Center: L_Count_1_ L a (1 + i) k v = L_Count_1_ K a (1 + i) k v).
  - rewrite Center.
    enough (Left: L_Count_1_ L a i (1 + i) v = L_Count_1_ K a k (1 + k) v).
    rewrite Left.
    enough (Right: L_Count_1_ L a k (1 + k) v = L_Count_1_ K a i (1 + i) v).
    rewrite Right.
    auto with zarith.
    + rewrite <- Q_EqualRangesPreservesCount with (i := i) (t_1 := K); auto with zarith.
      replace (i + (1 + k) - k) with (1 + i) by lia.
      trivial.
      unfold P_EqualRanges_4_.
      unfold P_EqualRanges_3_.
      replace (1 + k - k) with 1 by lia.
      unfold P_EqualRanges_1_.
      intros.
      rewrite shift_associative.
      rewrite shift_associative.
      replace (k + i0) with k by lia.
      replace (i + i0) with i by lia.
      auto with zarith.
    + rewrite <- Q_EqualRangesPreservesCount with (i := k) (t_1 := K); auto with zarith.
      replace (k + (1 + i) - i) with (1  + k) by lia.
      trivial.
      unfold P_EqualRanges_4_.
      unfold P_EqualRanges_3_.
      replace (1 + i - i) with (1) by lia.
      unfold P_EqualRanges_1_.
      intros.
      rewrite shift_associative.
      rewrite shift_associative.
      replace (k + i0) with k by lia.
      replace (i + i0) with i by lia.
      auto with zarith.
  - rewrite A_CountAxiomatic.Q_CountSectionRead with (t := K); auto with zarith.
Qed.

Goal typed_ref_external_lemma_SwappedInsidePerservesMultisetUnchanged.
Hint SwappedInsidePerservesMultisetUnchanged,property.
Proof.
  intros i k n M L K a.
  intros.
  assert(Swapped: P_SwappedInside M L a i k n) by assumption.
  destruct Swapped as [A1 [A2 [A3 [A4 [A5 [A6 [A7 A8]]]]]]].

  enough (ML: P_MultisetUnchanged_2_ M L a (1 + k)).
  - apply Q_MultisetUnchangedTransitive with (L); auto.
    + apply Q_MultisetUnchangedUnion with (i_1 := k); auto with zarith.
      apply Q_UnchangedImpliesMultisetUnchanged; auto.
      apply Q_UnchangedSection with (k) (n); auto with zarith.
  - apply Q_MultisetUnchangedUnion with (i_1 := i); auto with zarith.
    + apply Q_SwappedInsideMultisetUnchanged with (i := n); auto.
    + apply Q_UnchangedImpliesMultisetUnchanged; auto.
Qed.

Goal typed_ref_external_lemma_SwappedInsidePreservesMultisetUnchanged.
Hint SwappedInsidePreservesMultisetUnchanged,property.
Proof.
  intros i k n M L K a.
  intros.
  assert(Swapped: P_SwappedInside M L a i k n) by assumption.
  destruct Swapped as [A1 [A2 [A3 [A4 [A5 [A6 [A7 A8]]]]]]].

  enough (ML: P_MultisetUnchanged_2_ M L a (1 + k)).
  - apply Q_MultisetUnchangedTransitive with (L); auto.
    + apply Q_MultisetUnchangedUnion with (i_1 := k); auto with zarith.
      apply Q_UnchangedImpliesMultisetUnchanged; auto.
      apply Q_UnchangedSection with (k) (n); auto with zarith.
  - apply Q_MultisetUnchangedUnion with (i_1 := i); auto with zarith.
    + apply Q_SwappedInsideMultisetUnchanged with (i := n); auto.
    + apply Q_UnchangedImpliesMultisetUnchanged; auto.
Qed.

Goal typed_ref_external_lemma_UnchangedShift.
Hint UnchangedShift,property.
Proof.
  intros p q r K L.
  intros.
  unfold P_Unchanged_1_ in *.
  unfold shift_sint32 in *.
  intros.

  remember (i - p) as k.
  replace i with (p + k) by auto with zarith.
  replace (shift a (p + k)) with (shift (shift a p) k).
  - apply H; auto with zarith.
  - rewrite shift_associative.
    trivial.

Qed.

Goal typed_ref_external_lemma_UniquePartitionLowerBound.
Hint UniquePartitionLowerBound,property.
Proof.
  Require Import Psatz.
  intros n i L a.
  intros.
  assert (B: 0 < i \/ 0 = i) by (apply Zle_lt_or_eq; auto).
  destruct B as [pos|zero].
  - replace 0 with (L_UniquePartition L a n 0).
    enough(L_UniquePartition L a n 0 < L_UniquePartition L a n i); auto with zarith.
    apply A_UniquePartitionAxiomatic.Q_UniquePartitionMonotone; lia.
    rewrite Q_UniquePartitionZero; lia.
  - rewrite <- zero.
    rewrite Q_UniquePartitionZero; lia.
Qed.

Goal typed_ref_external_lemma_UniquePartitionUpperBound.
Hint UniquePartitionUpperBound,property.
Proof.
  Require Import Psatz.
  intros n i L a.
  intros.
  assert(X: L_UniquePartition L a n i < L_UniquePartition L a n (L_UniqueSize L a n)).
  - apply A_UniquePartitionAxiomatic.Q_UniquePartitionMonotone; lia.
  - assert(Y:  n = (L_UniquePartition L a n (L_UniqueSize L a n))).
    rewrite A_UniquePartitionAxiomatic.Q_UniquePartitionRight; auto with zarith.
    now rewrite <- Y in X.
Qed.

Goal typed_ref_external_lemma_UniquePreserve.
Hint UniquePreserve,property.
Proof.
  intros i n.
  intros L K a b.
  intros. subst x.
  unfold P_Unique. intros j. intros.

  rewrite <- H2; auto with zarith.
  - rewrite <- H4; auto with zarith.
    rewrite <- H3; auto with zarith.
    + replace (L_UniquePartition L a i j) with (L_UniquePartition K a i j); auto.
      rewrite <- A_UniquePartitionAxiomatic.Q_UniquePartitionRead with (t_1:=L); auto.
      apply Q_UnchangedSection with (i_3:=0) (i_2:=n); auto with zarith.
    + rewrite <- A_UniqueSizeAxiomatic.Q_UniqueSizeRead with (t_1 := L); auto with zarith.
      apply Q_UnchangedSection with (i_3:=0) (i_2:=n); auto with zarith.
  - apply Q_UniquePartitionLowerBound; auto with zarith.
  - enough (L_UniquePartition L a i j < i); auto with zarith.
    apply Q_UniquePartitionUpperBound; auto with zarith.
Qed.

Goal typed_ref_external_lemma_UniqueSizeBound.
Hint UniqueSizeBound,property.
Proof.
  intros n L a.
  intros X.
  subst X.
  generalize n as m.
  intros.

  apply natlike_rec2 with (z := m); auto with zarith.
  - rewrite A_UniqueSizeAxiomatic.Q_UniqueSizeEmpty; auto with zarith.
  - intros.
    Require Import Psatz.
    replace (Z.succ z) with (1+z) in * by lia.
    assert (B: 0 < z \/ 0 = z) by (apply Zle_lt_or_eq; auto).
    destruct B as [pos|zero].
    + assert (C: L.[ shift a z] = L.[ shift a (z-1)] \/ L.[ shift a z] <> L.[ shift a (z-1)]) by tauto.
      destruct C as [eq|neq].
      ++ rewrite A_UniqueSizeAxiomatic.Q_UniqueSizeEqual; auto with zarith.
      ++ rewrite <- A_UniqueSizeAxiomatic.Q_UniqueSizeDiffer; auto with zarith.
    + rewrite <- zero.
      replace (1+0) with 1 by lia.
      rewrite A_UniqueSizeAxiomatic.Q_UniqueSizeOne; lia.
Qed.

Goal typed_ref_external_lemma_UniqueSizeRead.
Hint UniqueSizeRead,property.
Proof.
Require Import Psatz.
intros n K L a.
assert (X: n <= 0 \/ n = 1 \/ n > 1) by lia.
destruct X as [lez|gtz].
{
  intro.
  assert (L_UniqueSize K a n = 0).
  {
    apply FixL_UniqueSize.
    assumption.
  }
  assert (L_UniqueSize L a n = 0).
  {
    apply FixL_UniqueSize.
    assumption.
  }
  intuition.
}
destruct gtz as [eqo|gto].
{
  intro.
  assert (L_UniqueSize K a n = 1).
  apply FixL_UniqueSize; intuition.
  assert (L_UniqueSize L a n = 1).
  apply FixL_UniqueSize; intuition.
  intuition.
}
apply Zlt_lower_bound_ind with (z := 1) (x := n); auto with zarith.
intros.
assert (x = 1 \/ x > 1) by lia.
destruct H2.
{
  assert (L_UniqueSize K a x = 1).
  apply FixL_UniqueSize; intuition.
  assert (L_UniqueSize L a x = 1).
  apply FixL_UniqueSize; intuition.
  intuition.
}
assert (P_Unchanged_2_ K L a (x-1) -> L_UniqueSize K a (x-1) = L_UniqueSize L a (x-1)).
{
  apply H; auto with zarith.
}
clear H.
unfold P_Unchanged_2_ in H1.
unfold P_Unchanged_1_ in H1.
assert (L.[shift_sint32 a (x-1)] = K.[shift_sint32 a (x-1)]). {
  apply H1; auto with zarith.
}
assert (L.[shift_sint32 a (x-2)] = K.[shift_sint32 a (x-2)]). {
  apply H1; auto with zarith.
}
pose (v := (if ((Zeq_bool (K.[shift_sint32 a (x-1)]) (K.[shift_sint32 a (x - 2)]))) then 0 else 1)).
assert (L_UniqueSize K a (x-1) + v = L_UniqueSize K a x). {
  apply FixL_UniqueSize; intuition.
}
pose (w := (if ((Zeq_bool (L.[shift_sint32 a (x-1)]) (L.[shift_sint32 a (x - 2)]))) then 0 else 1)).
assert (L_UniqueSize L a (x-1) + w = L_UniqueSize L a x). {
  apply FixL_UniqueSize; intuition.
}
assert (v = w).
{
  subst v.
  subst w.
  rewrite H.
  rewrite H4.
  reflexivity.
}
rewrite <- H5.
rewrite <- H6.
rewrite H7.
enough (L_UniqueSize K a (x - 1) = L_UniqueSize L a (x - 1)) by lia.
apply H3.
unfold P_Unchanged_2_.
unfold P_Unchanged_1_.
intros.
apply H1; auto with zarith.
Qed.

Goal typed_ref_external_lemma_UpperBoundShift.
Hint UpperBoundShift,property.
Proof.
  Require Import Psatz.
  unfold P_UpperBound_1_ in *.
  unfold shift_sint32 in *.
  intros.
  replace i0 with (i_1 + (i0 - i_1))%Z by lia.

  rewrite <- shift_associative.
  apply H0; lia.

Qed.

Goal typed_ref_external_lemma_WeaklySortedImpliesSorted.
Hint WeaklySortedImpliesSorted,property.
Proof.
  Require Import Psatz.
  intros m n L a MN.
  replace n with (m + (n-m)) by lia.

  apply natlike_rec2 with (z := (n - m)); auto with zarith.
  {
    intros.
    rewrite Zplus_0_r in *.
    unfold P_Sorted_1_.
    intros i j.
    intros.
    auto with zarith. (* empty domain *)
  }
  {
    intros.
    rename H0 into IndStep.
    rename H2 into IndHyp.

    replace (Z.succ z) with (1 + z) in * by auto with zarith.
    unfold P_Sorted_1_.
    intros i j.
    intros.

    assert(X: j < m + z \/ j >= m + z) by tauto.
    destruct X as [le|geq].
    {
      apply IndStep; auto with zarith.
      unfold P_WeaklySorted_1_.
      intros k. intros.
      apply IndHyp; auto with zarith.
    }
    {
      assert (eq: j = m + z) by auto with zarith.
      rewrite <- eq in *.
      assert(XX: i < j - 1 \/ i >= j - 1) by tauto.
      destruct XX as [le1|geq1].
      {
        assert(Y: L .[ shift_sint32 a (j-1)] <= L .[ shift_sint32 a j]).
        {
          replace j with (1 + (j-1)) by auto with zarith.
          replace ((1 + (j - 1) - 1)) with (j-1) by auto with zarith.
          unfold P_WeaklySorted_1_ in IndHyp.
          apply IndHyp; auto with zarith.
        }
        assert(Z: L.[ shift_sint32 a i] <= L .[ shift_sint32 a (j-1)]).
        {
          apply IndStep; auto with zarith.
          unfold P_WeaklySorted_1_.
          intros k. intros.
          apply IndHyp; auto with zarith.
        }
        auto with zarith.
      }
      {
        assert(EQ: i = j - 1) by auto with zarith.
        replace j with (1 + (j - 1)) by auto with zarith.
        rewrite EQ.
        apply IndHyp; auto with zarith.
      }
    }
  }
Qed.

Goal typed_ref_external_lemma_WeaklySortedShift.
Hint WeaklySortedShift,property.
Proof.
Require Import Psatz.
intros n m L a.
unfold P_WeaklySorted_1_.
unfold shift_sint32.
split.
+ intros H i LB UB.
  remember (i - n) as k.
  assert (LBZ: 0 <= k) by lia.
  assert (UBZ: 2 + k <= m) by lia.
  replace i with (n + k) by lia.
  rewrite <- shift_associative.
  replace (1 + (n + k)) with (n + (1 + k)) by lia.
  rewrite <- shift_associative.
  apply H; assumption.
+ intros H i LB UB.
  remember (i + n) as k.
  rewrite shift_associative.
  rewrite shift_associative.
  replace (n + (1 + i)) with (1 + (n + i)) by lia.
  apply H with (i := n + i); auto with zarith.
Qed.


